# Control Event, rendering

> React 요소의 이벤트를 제어하는 건 DOM 요소 이벤트를 제어하는 것과 매우 유사하나 몇가지 문법적 차이가 있다.
1. React 이벤트는 소문자 대신 `camelCase`를 사용한다.
    > 카멜표기법(camelCase)이란, 첫 문자는 소문자로, 띄어쓰기 대신 대문자로 표기하는 방법 
2. JSX에 문자열 대신 함수를 전달한다.

* 명시적 `preventDefault` : 자동렌더링(새로고침)을 명시적으로 호출 해야한다.
    > React에서 기본동작을 막기 위해 false 리턴을 사용할 수 없기 때문이다.
* 합성 이벤트 `e` : 브라우저 호환성을 가능케 해주는 함수의 이벤트를 `e`라 지칭한다.
* `addEventListener`를 호출할 필요가 없다 -> 대신 요소가 처음 렌더링될 때 리스너를 제공한다.
* 클래스 메서드는 기본적으로 `bound`되지 않는다.
    * 소괄호( ) 없이 메서드를 참조되기에 `bind` 해야한다.
    > 일반적으로 콜백에서 하위 컴포넌트에 `prop`를 전달하는 경우 큰 비용으로 렌더링될 수 있기에 성능 문제에 있어서 생성자 함수에 바인딩하거나 클래스 필드 문법을 사용하는 것이 좋다.

* `ReactDOM.render()` : React 요소를 루트 DOM 노드에 렌더링
    > 요소는 단일 프레임과 같이 한번 요소를 만들었다면, 그 자식이나 속성을 변경할 수 없다.
    * 대부분의 React 애플리케이션은 한번만 호출한다.

* 조건부 렌더링 : 애플리케이션의 state에 의존하여 그 중 일부만 렌더링한다.
    * 요소 변수 : 컴포넌트의 상태에 따라 전달될 props를 `if`문으로 구현한다.
    * 논리 연산자 (&&)가 있는 인라인 조건 : 중괄호를 감싸 일부 조건에 따라 사용한다.
    * 조건부 연산자 `condition ? true : false` : 텍스트 블록을 줄일 수 있다.
    * 컴포넌트가 렌더링 되지 못하도록 방지 : 컴포넌트가 다른 컴포넌트에 의해 렌더링 되더라도 이를 숨기기위해 prop의 요소의 값을 비교해 `null`을 반환한다.
    > 이 때 컴포넌트의 라이프사이클 메서드가 구동되지 않는 대신, `componentWillUpdate`와 `componentDidUpdate`는 호출된다.
